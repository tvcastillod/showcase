<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Introducción # En este ejercicio se ha realizado un ejemplo de postprocesado de una imagen. Aplicando distintos tipos de shaders a una misma imagen para ver los resultados que se obtienen y, además, examinar la relación entre dichos shaders y el orden en el que se aplican.
Antecedentes # Postprocesado # Los postefectos (o postprocesado) se refieren a las técnicas utilizadas después de la renderización de una imagen o un cuadro en una escena en tiempo real."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Introducción # En este ejercicio se ha realizado un ejemplo de postprocesado de una imagen. Aplicando distintos tipos de shaders a una misma imagen para ver los resultados que se obtienen y, además, examinar la relación entre dichos shaders y el orden en el que se aplican.
Antecedentes # Postprocesado # Los postefectos (o postprocesado) se refieren a las técnicas utilizadas después de la renderización de una imagen o un cuadro en una escena en tiempo real."><meta property="og:type" content="article"><meta property="og:url" content="https://jorodriguezal.github.io/showcase/docs/secciones/shaders-y-3D/posteffects/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-06-16T22:21:26-05:00"><title>Posteffects | Computación Visual</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Computación Visual</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Secciones</span><ul><li><input type=checkbox id=section-b487fddfe213dc98103a22e30f20cced class=toggle>
<label for=section-b487fddfe213dc98103a22e30f20cced class="flex justify-between"><a href=/showcase/docs/secciones/integrantes/>Integrantes</a></label><ul><li><a href=/showcase/docs/secciones/integrantes/Johan-Steeb-Rodr%C3%ADguez-Alarc%C3%B3n/>Johan Steeb Rodríguez Alarcón</a></li><li><a href=/showcase/docs/secciones/integrantes/Tania-Valentina-Castillo-Delgado/>Tania Valentina Castillo Delgado</a></li><li><a href=/showcase/docs/secciones/integrantes/Mar%C3%ADa-Alejandra-Jim%C3%A9nez-Herrera/>María Alejandra Jiménez Herrera</a></li></ul></li><li><input type=checkbox id=section-812d2262a05fbae8105f136b96854c26 class=toggle>
<label for=section-812d2262a05fbae8105f136b96854c26 class="flex justify-between"><a href=/showcase/docs/secciones/ilusiones-visuales/>Ilusiones Visuales</a></label><ul><li><a href=/showcase/docs/secciones/ilusiones-visuales/v%C3%ADdeo-de-presentaci%C3%B3n/>Vídeo De Presentación</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/Cuantificaci%C3%B3n-del-Color/>Cuantificación Del Color</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/fen%C3%B3meno-de-masking/>Fenómeno De Masking</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/coloraci%C3%B3n/>Coloración</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/percepci%C3%B3n-de-profundidad/>Percepción De Profundidad</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/bandas-mach/>Bandas Mach</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/Coherencia-espacial/>Coherencia Espacial</a></li></ul></li><li><input type=checkbox id=section-659412a241b7c379147b1b576e09e56a class=toggle checked>
<label for=section-659412a241b7c379147b1b576e09e56a class="flex justify-between"><a role=button>Shaders Y 3 D</a></label><ul><li><a href=/showcase/docs/secciones/shaders-y-3D/3d-model/>3d Model</a></li><li><a href=/showcase/docs/secciones/shaders-y-3D/Coloring/>Coloring</a></li><li><a href=/showcase/docs/secciones/shaders-y-3D/Procesamiento-de-Imagen/>Procesamiento De Imagen</a></li><li><a href=/showcase/docs/secciones/shaders-y-3D/texture-tinting/>Texture Tinting</a></li><li><input type=checkbox id=section-6f3b64a1ece7422886f04b1e6f71f135 class=toggle>
<label for=section-6f3b64a1ece7422886f04b1e6f71f135 class="flex justify-between"><a href=/showcase/docs/secciones/shaders-y-3D/coherencia-espacial/>Coherencia Espacial</a></label><ul><li><a href=/showcase/docs/secciones/shaders-y-3D/coherencia-espacial/Shaders/>Shaders</a></li><li><a href=/showcase/docs/secciones/shaders-y-3D/coherencia-espacial/Lineal/>Lineal</a></li></ul></li><li><a href=/showcase/docs/secciones/shaders-y-3D/posteffects/ class=active>Posteffects</a></li><li><a href=/showcase/docs/secciones/shaders-y-3D/procedural_texturing/>Procedural Texturing</a></li></ul></li><li><input type=checkbox id=section-6afa5302a62ba217d5088de37992068a class=toggle>
<label for=section-6afa5302a62ba217d5088de37992068a class="flex justify-between"><a href=/showcase/docs/secciones/p5/>P5</a></label><ul><li><a href=/showcase/docs/secciones/p5/iframe/>Iframe</a></li><li><a href=/showcase/docs/secciones/p5/div/>Div</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Posteffects</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#introducción>Introducción</a></li><li><a href=#antecedentes>Antecedentes</a><ul><li><a href=#postprocesado>Postprocesado</a></li><li><a href=#shaders>Shaders</a></li><li><a href=#cuantificación-de-colores>Cuantificación de colores</a></li></ul></li><li><a href=#ejercicio-realizado>Ejercicio Realizado</a><ul><li><a href=#método-utilizado>Método utilizado</a><ul><li><a href=#1-cuantización-de-colores>1. Cuantización de colores</a></li><li><a href=#2-efecto-de-deformación>2. Efecto de deformación</a></li><li><a href=#3-efecto-de-brillantez>3. Efecto de brillantez</a></li></ul></li></ul></li><li><a href=#resultados>Resultados</a><ul><li><a href=#cuantización-de-colores-seguido-de-efecto-de-brillantez-o-distorsión>Cuantización de colores seguido de efecto de brillantez o distorsión</a></li><li><a href=#efecto-de-brillantez-o-distorsión-seguido-de-cuantización-de-colores>Efecto de brillantez o distorsión seguido de cuantización de colores</a></li><li><a href=#código-fuente-de-los-shaders>Código fuente de los shaders</a></li></ul></li><li><a href=#conclusiones-y-trabajo-futuro>Conclusiones y trabajo futuro</a></li><li><a href=#referencias>Referencias</a></li></ul></nav></aside></header><article class=markdown><h1 id=introducción>Introducción
<a class=anchor href=#introducci%c3%b3n>#</a></h1><p>En este ejercicio se ha realizado un ejemplo de postprocesado de una imagen. Aplicando distintos tipos de shaders a una misma imagen para ver los resultados que se obtienen y, además, examinar la relación entre dichos shaders y el orden en el que se aplican.</p><h1 id=antecedentes>Antecedentes
<a class=anchor href=#antecedentes>#</a></h1><blockquote><h2 id=postprocesado>Postprocesado
<a class=anchor href=#postprocesado>#</a></h2><p style=text-align:justify>Los postefectos (o postprocesado) se refieren a las técnicas utilizadas después de la renderización de una imagen o un cuadro en una escena en tiempo real. Estas técnicas se aplican para mejorar la apariencia visual, ajustar los colores, simular efectos visuales o lograr estilos específicos.</p><p style=text-align:justify>Los postefectos se aplican generalmente a una imagen ya renderizada, en lugar de afectar directamente los objetos o materiales en la escena. Se utilizan para simular efectos de cámara, como desenfoque de movimiento, profundidad de campo, efecto de viñeta, aberración cromática o distorsión de lente. También se pueden aplicar para agregar efectos visuales, como efectos de partículas, destellos, efectos de luz o sombras, o incluso para simular estilos artísticos, como efectos de pintura o viñetas.</p><h2 id=shaders>Shaders
<a class=anchor href=#shaders>#</a></h2><p style=text-align:justify>Los shaders hacen referencia a programas que se ejecutan en la GPU. Estos programas se encargan de realizar los cálculos necesarios para generar los gráficos que se muestran en pantalla de una manera más rápida y eficiente. Los shaders se escriben en un lenguaje de programación llamado GLSL (OpenGL Shading Language).</p><h2 id=cuantificación-de-colores>Cuantificación de colores
<a class=anchor href=#cuantificaci%c3%b3n-de-colores>#</a></h2><p style=text-align:justify>La cuantización de colores es el proceso de reducir el número de colores distintos en una imagen. Esto se realiza para reducir el tamaño de la imagen y, por lo tanto, permitir que se almacene más imágenes en un disco o memoria. También se puede utilizar para reducir el número de colores en una imagen para que coincida con un dispositivo de visualización, como una impresora o un monitor, o para reducir el número de colores en una imagen para que coincida con el número de colores disponibles en un dispositivo de salida, como una impresora o un monitor.</p><p style=text-align:justify>Por lo general, estos son utilizados en la televisión el cine para reducir el tamaño de la imagen y, por lo tanto, permitir que se almacenen más imágenes en un disco o memoria, dándole más prioridad a la calidad de las áreas más importantes de la imagen y dejando las áreas menos importantes con una menor calidad. Esta provoca la aparición de artefactos en la imagen, como <b>bandas de color </b>, que son visibles en las áreas de la imagen con menos colores.</p><br><img src=/showcase/img/catband1.png height=50% width=50%>
<img src=/showcase/img/catband2.png height=50% width=50%></blockquote><h1 id=ejercicio-realizado>Ejercicio Realizado
<a class=anchor href=#ejercicio-realizado>#</a></h1><blockquote><blockquote class="book-hint info"><p style=text-align:justify>Implemente algunos efectos de postprocesado que encuentre interesantes.</blockquote><h2 id=método-utilizado>Método utilizado
<a class=anchor href=#m%c3%a9todo-utilizado>#</a></h2><p style=text-align:justify>Para la realización de este ejercicio se implementaron 3 shaders distintos, los cuales se aplicaron a una misma imagen. Los shaders implementados fueron los siguientes:</p><h3 id=1-cuantización-de-colores>1. Cuantización de colores
<a class=anchor href=#1-cuantizaci%c3%b3n-de-colores>#</a></h3><p style=text-align:justify>Este shader se encarga de reducir el número de colores de la imagen. Para esto, en el fragment shader, se obtiene el color de cada pixel y se elige desde el lado del usuario un valor de cuantización. Este valor se utiliza para calcular el nuevo color de cada pixel, el cual se obtiene con la operación <b>floor</b> de la multiplicación del color original por el valor de cuantización y luego dividiendo el resultado por el valor de cuantización.</p><h3 id=2-efecto-de-deformación>2. Efecto de deformación
<a class=anchor href=#2-efecto-de-deformaci%c3%b3n>#</a></h3><p style=text-align:justify>Este se encarga de, a partir de una función para generar una curvatura, deformar la imagen de acuerdo con esta, utilizando una cierta área de la imagen elegida para aplicar el efecto del shader.</p><h3 id=3-efecto-de-brillantez>3. Efecto de brillantez
<a class=anchor href=#3-efecto-de-brillantez>#</a></h3><p style=text-align:justify>Este consiste en tomar el color de cada pixel y, a partir de este, calcular un nuevo color que se obtiene de la suma del color original y un valor de brillantez calculado a partir de la posición del pixel en la imagen con respecto a la posición del mouse.</p><p style=text-align:justify>También se analizará la relación entre el orden en el que se aplican los shaders, ya que los píxeles generados por un shader son los que se utilizan como entrada para el siguiente shader, por lo que el orden en el que se aplican los shaders puede afectar el resultado final.</p><p style=text-align:justify>Como herramientas de apoyo para la realización de este ejercicio se adaptó el código fuente de un shader de distorsión de imagen, el cual se puede encontrar en el siguiente enlace: <a href=https://www.shadertoy.com/view/wsfBz8>https://www.shadertoy.com/view/wsfBz8</a></p><p style=text-align:justify>También se utilizó la inteligencia artificial Github Copilot, la cual se encargó de sugerir código para la implementación de los shaders y la automatización de código repetitivo.</p></blockquote><h1 id=resultados>Resultados
<a class=anchor href=#resultados>#</a></h1><blockquote><p style=text-align:justify>Para este ejercicio se aplican a una imagen, de manera simultánea, dos filtros. El filtro de cuantización de colores siempre se está aplicando, mientras que los filtros de deformación y brillantez no se aplican simultáneamente, sino que se elige uno de los dos para aplicar a la imagen. Para el filtro de cuantización se cuenta con un slider en la parte superior izquierda de la pantalla para elegir el valor de cuantización, mientras que para los filtros de deformación y brillantez se cuenta con un slider en la parte superior derecha de la pantalla para elegir el radio del área de la imagen en la que se aplicará el efecto del filtro y un botón para elegir el filtro que se aplicará a la imagen. En caso de seleccionar el filtro de deformación, se cuenta con un slider en la parte inferior de la pantalla para elegir el valor de la curvatura.</p><p>Estos son los dos posibles órdenes en los que se aplican los filtros:</p><h2 id=cuantización-de-colores-seguido-de-efecto-de-brillantez-o-distorsión>Cuantización de colores seguido de efecto de brillantez o distorsión
<a class=anchor href=#cuantizaci%c3%b3n-de-colores-seguido-de-efecto-de-brillantez-o-distorsi%c3%b3n>#</a></h2><p style=text-align:justify>En este caso, el filtro de cuantización de colores se aplica primero, seguido del filtro de brillantez o distorsión, dependiendo de cuál de los dos se elija. En este caso, el filtro de cuantización de colores se aplica a la imagen completa, mientras que el filtro de brillantez o distorsión se aplica a una cierta área de la imagen, la cual se depende de la posición del mouse:</p><br><iframe id=sketch style=width:725px;height:525px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.min.js></script>
            <script src=https://freshfork.github.io/p5.EasyCam/p5.easycam.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/postEffects/sketch.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><br><p style=text-align:justify>En este caso, como el filtro de cuantización de colores se aplica primero, el filtro de brillantez o distorsión se aplica a la imagen resultante de aplicar el filtro de cuantización de colores. Esto da como resultado que, en el caso del filtro de brillantez, no se evidencien bandas de color en el degradado de dicho filtro a medida que se aleja un pixel de la posición del mouse, ya que, aunque se redujo la cantidad de colores en el primer filtro, en el segundo se vuelven a aumentar al realizar el cálculo del efecto degradado.</p><br><p>En este caso, la función <code>draw()</code> del sketch se ve de la siguiente manera:</p><br><details><summary>Aplicación del orden de los shaders</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>img</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. Apply quantization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>quant_pg</span>.<span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>125</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>quant</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;texture&#34;</span>, <span style=color:#a6e22e>img</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>quant</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;uDivisor&#34;</span>, <span style=color:#a6e22e>quantization</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>quant_pg</span>.<span style=color:#a6e22e>emitResolution</span>(<span style=color:#a6e22e>quant</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>quant_pg</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. Apply brightness or distortion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>currentShader</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;woo&#34;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>scaleSlider</span>.<span style=color:#a6e22e>show</span>(); 
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo_pg</span>.<span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>125</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;texture&#34;</span>, <span style=color:#a6e22e>pg</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo_pg</span>.<span style=color:#a6e22e>emitPointerPosition</span>(<span style=color:#a6e22e>woo</span>, <span style=color:#a6e22e>mouseX</span>, <span style=color:#a6e22e>mouseY</span>, <span style=color:#e6db74>&#34;iMouse&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;iChannel0&#34;</span>, <span style=color:#a6e22e>pg</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo_pg</span>.<span style=color:#a6e22e>emitResolution</span>(<span style=color:#a6e22e>woo</span>, <span style=color:#e6db74>&#34;iResolution&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;radio&#34;</span>, <span style=color:#a6e22e>distanceThresholdSlider</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;scale&#34;</span>, <span style=color:#a6e22e>scaleSlider</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>woo_pg</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>scaleSlider</span>.<span style=color:#a6e22e>hide</span>(); 
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>bright_pg</span>.<span style=color:#a6e22e>emitPointerPosition</span>(<span style=color:#a6e22e>bright</span>, <span style=color:#a6e22e>mouseX</span>, <span style=color:#a6e22e>mouseY</span>, <span style=color:#e6db74>&#34;iMouse&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>bright</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;texture&#34;</span>, <span style=color:#a6e22e>pg</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>bright</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;distanceThreshold&#34;</span>, <span style=color:#a6e22e>distanceThresholdSlider</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>bright_pg</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>image</span>(<span style=color:#a6e22e>pg</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><br><p>Donde se evidencia el orden en que se aplican los shaders.</p><h2 id=efecto-de-brillantez-o-distorsión-seguido-de-cuantización-de-colores>Efecto de brillantez o distorsión seguido de cuantización de colores
<a class=anchor href=#efecto-de-brillantez-o-distorsi%c3%b3n-seguido-de-cuantizaci%c3%b3n-de-colores>#</a></h2><p style=text-align:justify>En este caso, el filtro de brillantez o distorsión se aplica primero, seguido del filtro de cuantización de colores:</p><br><iframe id=sketch2 style=width:725px;height:525px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.min.js></script>
            <script src=https://freshfork.github.io/p5.EasyCam/p5.easycam.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/postEffects/sketch2.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><br><p style=text-align:justify>Se puede evidenciar que, como el filtro de brillantez se aplica primero, hay bandas de color en el degradado de dicho filtro a medida que se aleja un pixel de la posición del mouse, ya que primero se calcula el efecto degradado y luego se reduce la cantidad de colores en la imagen, lo que da como resultado que el degradado se vea afectado por la cuantización de colores.</p><br><p style=text-align:justify>Además, esto se puede evidenciar aún más entre más se reduzca la cantidad de colores en la imagen, ya que, las áreas en las que anteriormente se veía un color más cercano a negro al reducir la cantidad de colores, se aumentó el brillo de sus píxeles antes de aplicar este filtro, haciendo que no se pierda totalmente la información del contenido de esta área, teniendo también un efecto parecido al de una linterna en la imagen:</p><br><img src=/showcase/img/brightquant.png><br><p>Contrario a lo que pasa con el orden inicial:</p><br><img src=/showcase/img/quantbright.png><br><p>El código de la función <code>draw()</code> para este orden fue:</p><br><details><summary>Aplicación del orden de los shaders</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>img</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>currentShader</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;woo&#34;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 1. Apply brightness or deformation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#a6e22e>scaleSlider</span>.<span style=color:#a6e22e>show</span>();
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo_pg</span>.<span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>125</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;texture&#34;</span>, <span style=color:#a6e22e>img</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo_pg</span>.<span style=color:#a6e22e>emitPointerPosition</span>(<span style=color:#a6e22e>woo</span>, <span style=color:#a6e22e>mouseX</span>, <span style=color:#a6e22e>mouseY</span>, <span style=color:#e6db74>&#34;iMouse&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;iChannel0&#34;</span>, <span style=color:#a6e22e>img</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo_pg</span>.<span style=color:#a6e22e>emitResolution</span>(<span style=color:#a6e22e>woo</span>, <span style=color:#e6db74>&#34;iResolution&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;radio&#34;</span>, <span style=color:#a6e22e>distanceThresholdSlider</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>woo</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;scale&#34;</span>, <span style=color:#a6e22e>scaleSlider</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>woo_pg</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>scaleSlider</span>.<span style=color:#a6e22e>hide</span>(); 
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>bright_pg</span>.<span style=color:#a6e22e>emitPointerPosition</span>(<span style=color:#a6e22e>bright</span>, <span style=color:#a6e22e>mouseX</span>, <span style=color:#a6e22e>mouseY</span>, <span style=color:#e6db74>&#34;iMouse&#34;</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>bright</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;texture&#34;</span>, <span style=color:#a6e22e>img</span>);
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>bright</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;distanceThreshold&#34;</span>, <span style=color:#a6e22e>distanceThresholdSlider</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>bright_pg</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. Apply quantization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>quant_pg</span>.<span style=color:#a6e22e>background</span>(<span style=color:#ae81ff>125</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>quant</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;texture&#34;</span>, <span style=color:#a6e22e>pg</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>quant</span>.<span style=color:#a6e22e>setUniform</span>(<span style=color:#e6db74>&#34;uDivisor&#34;</span>, <span style=color:#a6e22e>quantization</span>.<span style=color:#a6e22e>value</span>());
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>quant_pg</span>.<span style=color:#a6e22e>emitResolution</span>(<span style=color:#a6e22e>quant</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>quant_pg</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pg</span>.<span style=color:#a6e22e>quad</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>image</span>(<span style=color:#a6e22e>pg</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span></code></pre></div></div></details><p style=text-align:justify>Finalmente, también se identifica que, ya que este tiene que ver con la posición de los píxeles y no de su color, el orden resulta irrelevante en el caso del filtro de distorsión.</p><h2 id=código-fuente-de-los-shaders>Código fuente de los shaders
<a class=anchor href=#c%c3%b3digo-fuente-de-los-shaders>#</a></h2><p>En primer lugar, se encuentra el código fuente del shader de cuantización de colores, para este se explicó su funcionamiento en una sección anterior:</p><br><details><summary>Código fuente del shader de cuantización de colores</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>sampler2D</span> texture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> uDivisor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>varying</span> <span style=color:#66d9ef>vec2</span> texcoords2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>vec4</span> color <span style=color:#f92672>=</span> texture2D(texture, texcoords2);
</span></span><span style=display:flex><span>  color.rgb <span style=color:#f92672>=</span> floor(color.rgb <span style=color:#f92672>*</span> uDivisor) <span style=color:#f92672>/</span> uDivisor; <span style=color:#75715e>//change color depth</span>
</span></span><span style=display:flex><span>  gl_FragColor <span style=color:#f92672>=</span> color;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><br><p>En segundo lugar, se encuentra el código fuente del shader de brillantez, el cual aumenta los valores de los píxeles de la imagen en un radio determinado alrededor de la posición del mouse, y disminuye los valores de los píxeles de la imagen en un radio mayor alrededor de la posición del mouse:</p><br><details><summary>Código fuente del shader de brillantez</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>sampler2D</span> texture;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> iMouse;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> distanceThreshold;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>varying</span> <span style=color:#66d9ef>vec2</span> texcoords2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> pct <span style=color:#f92672>=</span> distance(gl_FragCoord.xy, iMouse);
</span></span><span style=display:flex><span>    pct <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> pct <span style=color:#f92672>/</span> distanceThreshold;
</span></span><span style=display:flex><span>    pct <span style=color:#f92672>=</span> clamp(pct, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>1.0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec4</span> color <span style=color:#f92672>=</span> texture2D(texture, texcoords2);
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#f92672>=</span> color <span style=color:#f92672>+</span> <span style=color:#66d9ef>vec4</span>(pct, pct, pct, <span style=color:#ae81ff>0.0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><br><p>En tercer lugar, se encuentra el código fuente del shader de distorsión, el cual distorsiona la imagen en un radio determinado alrededor de la posición del mouse dado un factor de curvatura:</p><br><details><summary>Código fuente del shader de distorsión</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-glsl data-lang=glsl><span style=display:flex><span><span style=color:#75715e>#ifdef GL_ES</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>precision</span> <span style=color:#66d9ef>mediump</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> iResolution;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>vec2</span> iMouse;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> iTime;
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>sampler2D</span> iChannel0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> radio;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uniform</span> <span style=color:#66d9ef>float</span> scale;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//function to calculate the curvature of the distortion</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>vec2</span> curvatureGenerator(<span style=color:#66d9ef>vec2</span> toPow, <span style=color:#66d9ef>float</span> dis) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> x <span style=color:#f92672>=</span> dis <span style=color:#f92672>/</span> radio;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> toPow <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> x) <span style=color:#f92672>*</span> exp(<span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span> <span style=color:#f92672>*</span> x <span style=color:#f92672>*</span> x);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> uv <span style=color:#f92672>=</span> <span style=color:#66d9ef>vec2</span>(gl_FragCoord.x <span style=color:#f92672>/</span> iResolution.x, <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> (gl_FragCoord.y <span style=color:#f92672>/</span> iResolution.y));<span style=color:#75715e>//1 - y / height (porque la y esta invertida)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec4</span> fragColor <span style=color:#f92672>=</span> texture2D(iChannel0, uv);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> center <span style=color:#f92672>=</span> iMouse.xy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> dis <span style=color:#f92672>=</span> distance(gl_FragCoord.xy, center);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>vec2</span> disV <span style=color:#f92672>=</span> gl_FragCoord.xy <span style=color:#f92672>-</span> center;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (dis <span style=color:#f92672>&lt;</span> radio) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//apply the curvature</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>vec2</span> trueUV <span style=color:#f92672>=</span> (gl_FragCoord.xy <span style=color:#f92672>-</span> (curvatureGenerator(disV, dis) <span style=color:#f92672>*</span> scale)) <span style=color:#f92672>/</span> iResolution.xy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//invert the y axis</span>
</span></span><span style=display:flex><span>        trueUV.y <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>-</span> trueUV.y; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        fragColor <span style=color:#f92672>=</span> texture2D(iChannel0, trueUV);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    gl_FragColor <span style=color:#f92672>=</span> fragColor;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><br><p>Donde la función <code>curvatureGenerator()</code> es la que calcula la curvatura de la distorsión.</p><br><p>Este shader fue adaptado de <a href=https://www.shadertoy.com/view/wsfBz8>este</a> shader de Shadertoy.</p></blockquote><h1 id=conclusiones-y-trabajo-futuro>Conclusiones y trabajo futuro
<a class=anchor href=#conclusiones-y-trabajo-futuro>#</a></h1><blockquote><p style=text-align:justify>Mediante este ejercicio se logró entender la utilidad de la aplicación de múltiples shaders a una sola imagen para lograr efectos más complejos. También se descubrió la utilidad de los objetos `PGraphics` para poder aplicar múltiples shaders a una sola imagen y la eficiencia de estos métodos en comparación con el tratamiento de imágenes por software. También se entendió que, cuando se trabaja con distintos shaders, el orden en el que se aplican es importante, ya que el resultado final puede variar dependiendo de este, demostrando que estos, además de tener cierto valor independiente, pueden hacer emerger un comportamiento más complejo cuando se combinan, lo cual abre más posibilidades de creación de efectos visuales.</p><p style=text-align:justify>Como trabajo futuro, se tiene un universo de posibilidades, ya que existe una gran variedad de posibles efectos y shaders que se pueden aplicar para obtener resultados más complejos. Además, esta herramienta podría ayudar a la creación de proyectos más grandes como editor de imágenes o de video, o incluso de videojuegos, para los cuales se pueden aplicar distintos efectos visuales de manera interactiva.</p><p style=text-align:justify>Finalmente, la Inteligencia Artificial es una herramienta muy útil para la creación de efectos visuales, ya que puede agilizar el proceso de desarrollo y entender el lenguaje natural para aplicar en los shaders distintos ajustes o refactorizaciones que se requieran para lograr el efecto deseado.</p></blockquote><h1 id=referencias>Referencias
<a class=anchor href=#referencias>#</a></h1><ol><li><a href=https://github.com/features/copilot>https://github.com/features/copilot</a></li><li><a href=https://visualcomputing.github.io/docs/shaders/post_effects/>https://visualcomputing.github.io/docs/shaders/post_effects/</a></li><li><a href=https://www.shadertoy.com/view/wsfBz8>https://www.shadertoy.com/view/wsfBz8</a></li><li><a href=https://www.neilmendoza.com/ofxpostprocessing/>https://www.neilmendoza.com/ofxpostprocessing/</a></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/a032f2672c674e81f5cfe25949855a81bffe61ae title='Last modified by jorodriguezal | June 17, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>June 17, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#introducción>Introducción</a></li><li><a href=#antecedentes>Antecedentes</a><ul><li><a href=#postprocesado>Postprocesado</a></li><li><a href=#shaders>Shaders</a></li><li><a href=#cuantificación-de-colores>Cuantificación de colores</a></li></ul></li><li><a href=#ejercicio-realizado>Ejercicio Realizado</a><ul><li><a href=#método-utilizado>Método utilizado</a><ul><li><a href=#1-cuantización-de-colores>1. Cuantización de colores</a></li><li><a href=#2-efecto-de-deformación>2. Efecto de deformación</a></li><li><a href=#3-efecto-de-brillantez>3. Efecto de brillantez</a></li></ul></li></ul></li><li><a href=#resultados>Resultados</a><ul><li><a href=#cuantización-de-colores-seguido-de-efecto-de-brillantez-o-distorsión>Cuantización de colores seguido de efecto de brillantez o distorsión</a></li><li><a href=#efecto-de-brillantez-o-distorsión-seguido-de-cuantización-de-colores>Efecto de brillantez o distorsión seguido de cuantización de colores</a></li><li><a href=#código-fuente-de-los-shaders>Código fuente de los shaders</a></li></ul></li><li><a href=#conclusiones-y-trabajo-futuro>Conclusiones y trabajo futuro</a></li><li><a href=#referencias>Referencias</a></li></ul></nav></div></aside></main></body></html>