<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Pixelamos un video # 1.Antecedentes # La técnica de pixelar imágenes ha sido utilizada desde hace décadas en diversos campos, como la fotografía, el cine, los videojuegos y el arte digital. Consiste en reducir la resolución de una imagen al agrupar los píxeles en bloques más grandes, dando como resultado una imagen con un aspecto más &#34;borroso&#34;. En los últimos años, ha surgido un enfoque denominado &#34;Spatial coherence&#34; (coherencia espacial), que se enfoca en preservar la información visual de la imagen original, mientras se reduce la resolución."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Pixelamos un video # 1.Antecedentes # La técnica de pixelar imágenes ha sido utilizada desde hace décadas en diversos campos, como la fotografía, el cine, los videojuegos y el arte digital. Consiste en reducir la resolución de una imagen al agrupar los píxeles en bloques más grandes, dando como resultado una imagen con un aspecto más &#34;borroso&#34;. En los últimos años, ha surgido un enfoque denominado &#34;Spatial coherence&#34; (coherencia espacial), que se enfoca en preservar la información visual de la imagen original, mientras se reduce la resolución."><meta property="og:type" content="article"><meta property="og:url" content="https://jorodriguezal.github.io/showcase/docs/secciones/ilusiones-visuales/Coherencia-espacial/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-03-22T19:55:30-05:00"><title>Coherencia Espacial | Computación Visual</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.3a8d658c77eb93c7f12a2b8af49a700131e474f288eefb605d9fa61576dbe5a7.js integrity="sha256-Oo1ljHfrk8fxKiuK9JpwATHkdPKI7vtgXZ+mFXbb5ac=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Computación Visual</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Secciones</span><ul><li><input type=checkbox id=section-812d2262a05fbae8105f136b96854c26 class=toggle checked>
<label for=section-812d2262a05fbae8105f136b96854c26 class="flex justify-between"><a href=/showcase/docs/secciones/ilusiones-visuales/>Ilusiones Visuales</a></label><ul><li><a href=/showcase/docs/secciones/ilusiones-visuales/fen%C3%B3meno-de-masking/>Fenómeno De Masking</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/introducci%C3%B3n/>Introducción</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/coloraci%C3%B3n/>Coloración</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/Coherencia-espacial/ class=active>Coherencia Espacial</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/percepci%C3%B3n-de-profundidad/>Percepción De Profundidad</a></li><li><a href=/showcase/docs/secciones/ilusiones-visuales/bandas-mach/>Bandas Mach</a></li></ul></li><li><input type=checkbox id=section-b487fddfe213dc98103a22e30f20cced class=toggle>
<label for=section-b487fddfe213dc98103a22e30f20cced class="flex justify-between"><a href=/showcase/docs/secciones/integrantes/>Integrantes</a></label><ul><li><a href=/showcase/docs/secciones/integrantes/Johan-Steeb-Rodr%C3%ADguez-Alarc%C3%B3n/>Johan Steeb Rodríguez Alarcón</a></li><li><a href=/showcase/docs/secciones/integrantes/Mar%C3%ADa-Alejandra-Jim%C3%A9nez-Herrera/>María Alejandra Jiménez Herrera</a></li><li><a href=/showcase/docs/secciones/integrantes/Tania-Valentina-Castillo-Delgado/>Tania Valentina Castillo Delgado</a></li></ul></li><li><input type=checkbox id=section-6afa5302a62ba217d5088de37992068a class=toggle>
<label for=section-6afa5302a62ba217d5088de37992068a class="flex justify-between"><a href=/showcase/docs/secciones/p5/>P5</a></label><ul><li><a href=/showcase/docs/secciones/p5/iframe/>Iframe</a></li><li><a href=/showcase/docs/secciones/p5/div/>Div</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Coherencia Espacial</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#pixelamos-un-video>Pixelamos un video</a><ul><li><a href=#1antecedentes>1.Antecedentes</a></li><li><a href=#2-método>2. Método</a></li><li><a href=#3ejercicio>3.Ejercicio</a></li><li><a href=#4-resultados>4. Resultados</a><ul><li><a href=#imágenes>Imágenes</a></li><li><a href=#videos>Videos</a></li><li><a href=#spatialcoherence>SpatialCoherence</a></li></ul></li><li><a href=#5-fragmentos-de-código>5. Fragmentos de código</a></li><li><a href=#conclusiones>Conclusiones</a></li><li><a href=#7-bibliografía>7. Bibliografía</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=pixelamos-un-video>Pixelamos un video
<a class=anchor href=#pixelamos-un-video>#</a></h1><h2 id=1antecedentes>1.Antecedentes
<a class=anchor href=#1antecedentes>#</a></h2><blockquote><p style=text-align:justify>La técnica de pixelar imágenes ha sido utilizada desde hace décadas en diversos campos, como la fotografía, el cine, los videojuegos y el arte digital. Consiste en reducir la resolución de una imagen al agrupar los píxeles en bloques más grandes, dando como resultado una imagen con un aspecto más "borroso".<br>En los últimos años, ha surgido un enfoque denominado "Spatial coherence" (coherencia espacial), que se enfoca en preservar la información visual de la imagen original, mientras se reduce la resolución. En lugar de simplemente promediar los colores de cada bloque de píxeles, como se hace en la técnica de "color averaging", la técnica de "spatial coherence" utiliza un solo color arbitrario para cada bloque, con el objetivo de mantener la coherencia visual en toda la imagen.<br>Esta técnica ha ganado popularidad en el ámbito del arte digital y la creación de gráficos por ordenador, ya que permite crear imágenes con un aspecto único y creativo, mientras se reduce la cantidad de información necesaria para representar la imagen. En esta página se tratará de comparar estas dos técnicas para una imagen o video</p></blockquote><br><h2 id=2-método>2. Método
<a class=anchor href=#2-m%c3%a9todo>#</a></h2><blockquote><p style=text-align:justify>Para el desarrollo del ejercicio de hace uso de esta teoría ya descrita anteriormente de utiliza p5.js y se manejar imágenes y videos , para la técnica ColorAveraging se hace una media de los colores de cada bloque de píxeles determinado por un scrollbar y rápidamente se puede sacar el promedio de los nuevos bloques de pixeles para el siguiente fotograma del video. Para la técnica SpatialCoherence se utiliza un solo color arbitrario para cada bloque, con el objetivo de mantener la coherencia visual en toda la imagen.
Como parte del ejercicio también se hizo uso de ChatGPT para ponerlo a prueba en qué tanto código podía generar, y se obtuvo que si bien no servían del todo los códigos generados si fue de ayuda para el desarrollo del resultado final del ejercicio. Se mostrarán fragmentos de código generador por la AI y cuáles de usaron y cuales no en la sección de fragmentos de código.</blockquote></p><h2 id=3ejercicio>3.Ejercicio
<a class=anchor href=#3ejercicio>#</a></h2><blockquote class="book-hint info">Implement a pixelator video application and perform a benchmark of the results (color avg vs spatial coherence). How would you assess the visual quality of the results?</blockquote><h2 id=4-resultados>4. Resultados
<a class=anchor href=#4-resultados>#</a></h2><h3 id=imágenes>Imágenes
<a class=anchor href=#im%c3%a1genes>#</a></h3><blockquote><p style=text-align:justify>En primer lugar se tiene el video que se puede observar en la siguiente imagen,en el cual se puede variar la cantidad de bloques de pixeles con un scrollbar, y se puede observar que al aumentar el tamaño de los bloques de pixeles(disminuir la cantidad de bloques), la imagen se vuelve más borrosa, y al disminuir el tamaño de los bloques de pixeles(aumentar la cantidad de bloques), la imagen se vuelve más nítida.
este programa no consume tantos recursos por lo que corre bien con un video de alta calidad.</p></blockquote><p>color averaging</p><iframe id=pix_image style=width:640px;height:360px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/spatial_coherence/pix_image.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><p>spatial coherence</p><iframe id=SC_image style=width:640px;height:360px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/spatial_coherence/SC_image.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h3 id=videos>Videos
<a class=anchor href=#videos>#</a></h3><p>color averaging</p><iframe id=pix_video style=width:640px;height:360px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/spatial_coherence/pix_video.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><p>spatial coherence</p><iframe id=SC_video style=width:640px;height:360px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=/showcase/sketches/spatial_coherence/SC_video.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h3 id=spatialcoherence>SpatialCoherence
<a class=anchor href=#spatialcoherence>#</a></h3><blockquote><p style=text-align:justify>En segundo lugar para esta parte del ejercicio no se ha logrado el programa con un video ya que es muy pesado y se queda sin recursos fácilmente,por lo que se ha hecho con una imagen, en la cual se puede observar que al aumentar el tamaño de los bloques de pixeles(disminuir la cantidad de bloques), la imagen se vuelve más borrosa, y al disminuir el tamaño de los bloques de pixeles(aumentar la cantidad de bloques), la imagen se vuelve más nítida.
Para comparar los métodos se puede observar ambios programas con una imágen</blockquote></p><h2 id=5-fragmentos-de-código>5. Fragmentos de código
<a class=anchor href=#5-fragmentos-de-c%c3%b3digo>#</a></h2><p>Aquí un ejemplo de fragmento de código generado por ChatGPT que no se utilizó en el ejercicio:</p><details><summary>Función obtener color más frecuente</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getMostCommonColorInBlock</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>blockSize</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>colorCounts</span> <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>x</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>blockSize</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>y</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>blockSize</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>colorKey</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>colorCounts</span>[<span style=color:#a6e22e>colorKey</span>]) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>colorCounts</span>[<span style=color:#a6e22e>colorKey</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>colorCounts</span>[<span style=color:#a6e22e>colorKey</span>]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>maxCount</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>mostCommonColor</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>colorKey</span> <span style=color:#66d9ef>in</span> <span style=color:#a6e22e>colorCounts</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>colorCounts</span>[<span style=color:#a6e22e>colorKey</span>] <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>maxCount</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>maxCount</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>colorCounts</span>[<span style=color:#a6e22e>colorKey</span>];
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>mostCommonColor</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>colorKey</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;,&#34;</span>).<span style=color:#a6e22e>map</span>(Number);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>color</span>(<span style=color:#a6e22e>mostCommonColor</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><p align=justify>Esto por lo que Spathial_Coherence no busca el color más común en cada bloque de pixeles, sino que elige un color arbitrario para cada bloque. Y esta función hacía que la complejidad del algoritmo fuera muy alta, tanto que incluso se demoraba ejecutando para una sola imagen.</p><p align=justify>Ya con los cambios requeridos y ajustes efectuados, la implementación del ejercicio quedó así:</p><details><summary>Función spathialCoherence</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>pixelateSpatialCoherence</span>(<span style=color:#a6e22e>originalImg</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// crear una nueva imagen pixelada
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>pixelatedImg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createImage</span>(<span style=color:#a6e22e>originalImg</span>.<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>originalImg</span>.<span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// cargar la imagen original en la nueva imagen pixelada
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pixelatedImg</span>.<span style=color:#a6e22e>copy</span>(<span style=color:#a6e22e>originalImg</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>originalImg</span>.<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>originalImg</span>.<span style=color:#a6e22e>height</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>originalImg</span>.<span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>originalImg</span>.<span style=color:#a6e22e>height</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// loop para recorrer cada bloque en la imagen pixelada
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>pixelatedImg</span>.<span style=color:#a6e22e>width</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>blockSize</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>pixelatedImg</span>.<span style=color:#a6e22e>height</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>blockSize</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// obtener un color aleatorio dentro del bloque
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>randX</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>random</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>blockSize</span>));
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>randY</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>floor</span>(<span style=color:#a6e22e>random</span>(<span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>y</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>blockSize</span>));
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>blockColor</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>originalImg</span>.<span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>randX</span>, <span style=color:#a6e22e>randY</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// loop para recorrer cada pixel en el bloque
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>x</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>blockSize</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>y</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>blockSize</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// asignar el color aleatorio al pixel en la imagen pixelada
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#a6e22e>pixelatedImg</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>blockColor</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div></div></details><br>Para lo que sí fue de gran utilidad ChatGPT fue para generar pequeños componentes del programa como por ejemplo la descomposición de un video en imágenes,no fue utilizada exactamente igual pero en su momento fue de gran apoyo:
<details><summary>Función para descomponer un video en imágenes</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>video</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>totalFrames</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>; <span style=color:#75715e>// número total de fotogramas a extraer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>currentFrame</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// fotograma actual
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setup</span>() {
</span></span><span style=display:flex><span><span style=color:#a6e22e>createCanvas</span>(<span style=color:#ae81ff>640</span>, <span style=color:#ae81ff>480</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>video</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createVideo</span>(<span style=color:#e6db74>&#39;mi_video.mp4&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>video</span>.<span style=color:#a6e22e>hide</span>(); <span style=color:#75715e>// oculta el elemento &lt;video&gt; en la página
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>video</span>.<span style=color:#a6e22e>play</span>(); <span style=color:#75715e>// comienza a reproducir el video
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>currentFrame</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>totalFrames</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>filename</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;frame_&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>nf</span>(<span style=color:#a6e22e>currentFrame</span>, <span style=color:#ae81ff>4</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;.png&#39;</span>; <span style=color:#75715e>// nombre del archivo de imagen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>width</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>height</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>image</span>(<span style=color:#a6e22e>video</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>h</span>); <span style=color:#75715e>// dibuja el video en el lienzo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>saveCanvas</span>(<span style=color:#a6e22e>filename</span>); <span style=color:#75715e>// guarda el fotograma actual como imagen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>currentFrame</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>video</span>.<span style=color:#a6e22e>time</span>(<span style=color:#a6e22e>currentFrame</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>totalFrames</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>video</span>.<span style=color:#a6e22e>duration</span>()); <span style=color:#75715e>// cambia el tiempo del video
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>video</span>.<span style=color:#a6e22e>stop</span>(); <span style=color:#75715e>// detiene la reproducción del video
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>noLoop</span>(); <span style=color:#75715e>// detiene el bucle de dibujo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></details><h2 id=conclusiones>Conclusiones
<a class=anchor href=#conclusiones>#</a></h2><br><p align=justify>1. Para el desarrollo del video se requirió poner un video de baja calidad y pocos fotogramas ya que si se subía el programa no corría, especialmente con spathial coherence ya que el proceso de manera lineal cuesta mucho computacionalmente.</p><br><p align=justify>2. Como se puede observar en los ejercicios el Pixel averaging es más rápido que el spatial coherence, pero el spatial coherence es más preciso y se puede observar que la imagen se ve más nítida que la del pixel averaging, por lo que se puede concluir que el spatial coherence es mejor que el pixel averaging.</p><br><p align=justify>3. Para observar mejor la diferencia entre esos dos métodos se puede intentar palarelizar el proceso de spatial coherence, ya que el proceso es lineal es demasiado costoso computacionalmente, por lo que se puede intentar paralelizar el proceso para que sea más rápido y se pueda observar mejor la diferencia entre los dos métodos.</p><br><p align=justify>4. ChatGPT es una herramienta muy útil par explicar funciones y temas, pero no es tan útil para generar código de manera automática, ya que el código generado no es muy útil o no se puede ejecutar, por lo que se debe hacer un proceso de limpieza y de adaptación del código generado para que realice lo que se quiere.</p><h2 id=7-bibliografía>7. Bibliografía
<a class=anchor href=#7-bibliograf%c3%ada>#</a></h2><blockquote><ol><li><p><a href=https://p5js.org/reference/>https://p5js.org/reference/</a><br></p></li><li><p><a href=https://visualcomputing.github.io/docs/visual_illusions/spatial_coherence/>VisualComputing</a><br></p></li><li><p><a href=https://chat.openai.com/chat>ChatGPT</a></p></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/visualcomputing/showcase/commit/679bbca89148feff64efb7a60b7c64e9500a6f77 title='Last modified by malejaj | March 23, 2023' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>March 23, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#pixelamos-un-video>Pixelamos un video</a><ul><li><a href=#1antecedentes>1.Antecedentes</a></li><li><a href=#2-método>2. Método</a></li><li><a href=#3ejercicio>3.Ejercicio</a></li><li><a href=#4-resultados>4. Resultados</a><ul><li><a href=#imágenes>Imágenes</a></li><li><a href=#videos>Videos</a></li><li><a href=#spatialcoherence>SpatialCoherence</a></li></ul></li><li><a href=#5-fragmentos-de-código>5. Fragmentos de código</a></li><li><a href=#conclusiones>Conclusiones</a></li><li><a href=#7-bibliografía>7. Bibliografía</a></li></ul></li></ul></nav></div></aside></main></body></html>